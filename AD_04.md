# Algoritm and Data Struct
Algoritm and Data Struct Recture

4강 다이나믹 프로그래밍
===========
## A. 다이나믹 프로그래밍이란
큰 문제를 작은문제로 나눠서 푸는 알고리즘

## B. 두가지 속성을 만족해야 한다.
1. Overlapping Subproblem : 문제를 작은문제로 쪼갤수 있으며 부분문제(작은 문제) 끼리 겹친다.
2. Optimal Substructure : 문제의 정답을 작은 문제의 정답에서 구할 수 있다.

## C. 피보나치 수열
* F0 = 0
* F1 = 1
* Fn = Fn-1 + Fn-2 (n >= 2)
* 0 1 1 2 3 5 8 13 21 34
* 문제 : N번째 피보나치 수를 구하는 문제
* 작은문제 : N-1 번쨰 피보나치 수를 구하는 문제, N-2번째 피보나치 수를 구하는 문제

1. Overlapping Subproblem
      1) 5번째 피보나치수를 구하는 문제 : F4를 구하는 문제, F3을 구하는 문제
      2) 4번째 피보나치수를 구하는 문제 : F3를 구하는 문제, F2을 구하는 문제
      3) 3번째 피보나치수를 구하는 문제 : F2를 구하는 문제, F1을 구하는 문제
      4) 2번째 피보나치수를 구하는 문제 : F1를 구하는 문제, F0을 구하는 문제
      5) F3, F2, F1 이 겹친다.

2. ptimal Substructure
      1) 5번째 피보나치수를 구하는 문제 : F4를 구하는 문제, F3을 구하는 문제, 문제의 정답을 작은 문제의 정답을 한한 것으로 구할 수 있다.
      2) 4번째 피보나치수를 구하는 문제 : F3를 구하는 문제, F2을 구하는 문제, 문제의 정답을 작은 문제의 정답을 한한 것으로 구할 수 있다.
      3) 3번째 피보나치수를 구하는 문제 : F2를 구하는 문제, F1을 구하는 문제, 문제의 정답을 작은 문제의 정답을 한한 것으로 구할 수 있다.
      4) 2번째 피보나치수를 구하는 문제 : F1를 구하는 문제, F0을 구하는 문제, 문제의 정답을 작은 문제의 정답을 한한 것으로 구할 수 있다.

3. Memorization
      1) 정답을 한번 구했으면 어딘가에 메모하여 저장 하는 것

4. 구현
``` swift
fib(4)
func fibonacci(n : Int) -> Int {
    guard n > 1 else { return n }
    print(n)
    return fib(n-1) + fib(n-2)
    /*
    4
    3
    2
    2
    */
}
``` 

5. 고민거리 : 호출시 F2 호출이 겹치게 된다. 중복호출이 안되도록 메모(배열)를 이용

<img src = "https://cdn-images-1.medium.com/max/1600/1*9tNzBsD415roh9K_scjF7A@2x.png" height = 350 width = 400>

``` swift
    func fibonacci(n : Int) -> Int {
        var fibs: [Int] = [1, 1]
        (2...n).forEach { i in
            fibs.append(fibs[i - 1] + fibs[i - 2])
        }
        return fibs.last!
    }
```

## D. 문제풀이 전략
1. Top-Down : 큰 문제를 풀어 작은문제를 푸는 방법 재귀함수 이용
2. Bottom-Up : 작은 문제를 풀어 큰 문제를 푸는 방법 for Loop 이용

## E. 1로 만들기
* 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

      1) X가 3으로 나누어 떨어지면, 3으로 나눈다.
      2) X가 2로 나누어 떨어지면, 2로 나눈다.
      3) 1을 뺀다.
      
* 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

* N = 2 // 1
* N = 10 // 3

* 풀이

      1) N = 0, N = 1 일때는 0이다. 1로 만들기 문제기 때문에 1보다는 커야 한다.
      2) N = 2 인 경우를 생각해 보자. 1로 만드는 경우의 수는 1 이 된다.
      3) N = 3 인 경우를 생각해 보자. 1로 만드는 경우의 수는 1 이 된다.
      4) N = 4 인 경우를 생각해 보자.

            * N-1 > 3 > N/3 > 1 > 2번
            * N/2 > 2 > N-1 > 1 > 2번
            
      5) N = 5 인 경우를 생각해 보자.

            * N-1 > 4 > N/2 > 1 > 2번
            
      6) 주어진 N을 1로 만드는 최소 횟수를 구하자는 의미
      7) N을 1로 만드는 경우의 수는 N -> ..... -> 1 D[N] 최소 가지수 
      8) N/3으로 나누어 떨어졌을때의 경우의 수는 N-> N/3 -> ...... -> 1
            
            * (N을 N/3으로 만드는 과정) + (N/3을 1로 만드는 과정) 
            * 1 + D[N/3] 최소 가지수
            
      9) N/2으로 나누어 떨어졌을때의 수는 N-> N/2 -> ...... -> 1
      
            * (N을 N/2으로 만드는 과정) + (N/2을 1로 만드는 과정)
            * 1 + D[N/2] 최소 가지수 
            
      10) N에서 1을 뺐을때의 경우의 수는 N-> N-1 -> ...... -> 1 
      
            * (N을 N/2으로 만드는 과정) + (N을 1로 만드는 과정)
            * 1 + D[N-1] 최소 가지수
            
      11) N-1 을 1로 만드는 최소 횟수 + 1 OR N/2 을 1로 만드는 최소 횟수 + 1 OR N/3 을 1로 만드는 최소 횟수 + 1
      
      
``` C   
#include <stdio.h>

#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))

int main(int argc, const char * argv[]) {
    // insert code here...

    int n, i , dp[1000001]; scanf("%d",&n);

    dp[0] = 0;
    dp[1] = 0;  //0,1일 때 횟수는 0번이다. 최소 1이상이여야 하기때문
    
    for (i = 2 ; i <= n ; i++){
        
        //1. 1을 빼는 계산부터 시작하기때문에 n/2, n/3 에서 이를 비교하여 최소값을 결정하여 dp[i]의 값을 저장한다.
        
        dp[i] = dp[i-1] + 1;
        
        if(i % 2 ==0){
            dp[i] = MIN(dp[i], dp[i/2] + 1);
        }
        if(i % 3 ==0){
            dp[i] = MIN(dp[i], dp[i/3] + 1);
        }
        
        //2. 이렇게 나온 dp[i] 란 i 라는 수를 1로 만드는 최소 값을 의미한다.
    }

    printf("%d",dp[n]);
    
    return 0;
}
```

## F. 2×n 타일링
* 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오. 아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.
<img src = "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11726/1.png" height = 200 width = 400>

* N = 2 // 2
* N = 9 // 55

* 풀이

      1) D[N]을 2xN을 채우는 방법의 수 라고 생각하자
      2) N = 0 이면 2 * 0 = 1
      
            * 공집합도 1개
            
      3) 2 * 1 = 1 
            
            * 세로로 긴 직사각형 1개
            
      4) 2 * 2 = 2
            
            * 세로로 긴 직사각형 2개 OR 가로로 긴 직사각형 2개
            
      5) 2 * 3 = 3
            
            * 세로로 긴 직사각형 1개 + 가로로 긴 직사각형 2개 OR 가로로 긴 직사각형 2개 + 세로로 긴 직사각형 2개 OR 세로로 긴 직사각형 3개
            
      6) D[N] = 앞에 타일이 1개 세로로 있을 경우 + 앞에 타일이 2개 가로로 있을 경우
      
      7) D[N] = D[N-1] + D[N-2]

``` C
      #include <stdio.h>

      #define MIN(X,Y) ((X) < (Y) ? (X) : (Y))

      int main(int argc, const char * argv[]) {

          int n, i , dp[1000001]; scanf("%d",&n);

          dp[0] = 1;
          dp[1] = 1;
    
          for (i = 2 ; i <= n ; i++)
          {

              dp[i] = dp[i-1] + dp[i-2];

          }

          printf("%d",dp[n]);
    
          return 0;
      }
```
